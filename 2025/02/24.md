## 取り組んだ課題一覧
- 【JS】ガチで学びたい人のためのJavaScriptメカニズム
## わかったこと
- &&演算子ではオペランドの中にfalsyな値があればその値を返し、無ければ一番最後の値を返す。trueやfalseを返すわけではない。
- ||演算子ではオペランドの中にtruthyな値があればその値を返し、無ければ一番最後の値を返す。trueやfalseを返すわけではない。
- name = name || 'Tom'と記述した場合、nameがfalsyな値(空など)であれば||の右辺がnameに代入されるが、0のようなfalsyな値をnameに使いたい場合は工夫しないと右辺が代入されてしまうので注意が必要。そして、ES6からはif文の仮引数にデフォルト値を設定できるようになった。if(name = 'Tom') {}
- name && hello(name);と記述した場合、nameがtruthyな値であれば&&の右辺が実行され、nameがfalsyな値であれば何も実行されない。&&の性質を使ってif文の内容を違った書き方で対応することも可能。
- 変数を定義して初期値を代入した後に別の値で再代入した場合、メモリ上の参照する値が変わっているだけで、初期を描き直したわけではない。
- let a = 'Hellow'; let b = a; とした場合、aとbは同じ値を返すが、参照しているメモリ上の場所は異なる。b = 'Bye';と再代入した場合、bが参照する値が変わるだけで、aには特に影響は無い。
- オブジェクトの参照に関して、let a = {prop: 'Hello'};として、let b = a; b.prop = 'Bye'と値を変更した場合、a.propとb.propは同じ値となる。オブジェクトの値を変更した場合はコピー元とコピー先の両方で変わるので注意。但し、参照するオブジェクト自体を変更した場合はそれぞれ違うオブジェクトを参照するので違う結果を返してくる。プロパティを変えるだけでは参照先は変わらない。
- プリミティブ型では参照先の値がコピーされるので、一方を変更しても他方には影響が無い。
- オブジェクトではオブジェクトへの参照がコピーされるので、同じオブジェクトを参照する。内容を変更すればコピー元とコピー先の両方に変更が反映される。参照先が同じなので。
- constを使った変数の定義では変数から値への参照がロックされており、結果として値の変更ができないという現象にたどり着く。これはオブジェクトの定義でも同じ挙動となる。
- constを使ってオブジェクトを定義した場合、オブジェクトの再代入はエラーとなるが、オブジェクト内のプロパティの値は変更することができる。
- function fn(a) {} の関数でlet b = 0; をfn(b);と呼び出した場合、let a = b; となり、仮引数aに実引数bを代入していることと同義となる。この場合、プリミティブ型であればbの参照している値をコピー・代入して、オブジェクトを参照している場合は同じオブジェクトを参照するようにコピーされる
- プリミティブ型を関数の引数として渡す場合、値はそれぞれ独立しているので干渉し合うことは無い
- オブジェクトを関数の引数として渡す場合、引数ととして渡された関数内でも同じオブジェクトを参照するようになるので、引数のプロパティ値を変更した場合、元のオブジェクトのプロパティ値も変更される
- 分割代入を利用すればオブジェクトのプロパティの値をコピーして、他の変数に代入することができる。これによりオブジェクト自体をコピーして同じオブジェクトを参照してしまう状態を避けることができる。
- オブジェクトの比較をする場合、オブジェクト同士を === で比較すると、中身は同じでも参照先のオブジェクトが異なるのでfalseが返ってくる。値を比較したい場合にはオブジェクトのプロパティ同士を比較する必要がある。
- === は値だけでなく型の比較も行う
- !を使うとオペランドをブール値(true or false)に変換して、その後に論理否定で反転させる
- if文の条件で仮引数に対してdefault値を使う場合、実引数が未定義の時のみ(undefined)default値が使用されるが、nullの場合は対象にならない。
- let obj5 = obj; をするとこの時点では同じオブジェクトを参照しているが、obj5 = {};を続けて実行するとobj5の参照先が変わるので、objとobj5の参照先は異なるものとなる。
### 関数の実引数にオブジェクトを渡した場合
- function through (obj) {return obj;}の関数で const obj2 = through(obj); を実行した場合、obj === obj2の厳密な比較はtrueとなる。これは定義文のobjと実行文のobjの参照先が同じなので、returnで返ってくる参照先も同じなので比較文はtureとなる。
### 関数に引数を渡す場合
- 複数の仮引数が設定されている場合に1つだけ渡したい時でも他の引数を省略することはできない。例えば、渡したくない引数の所にはnullを渡すと必要な引数だけ渡すことはできる。複数の引数が必要な場合に仮引数の数よりも少ない実引数を渡すと不足部分はundefinedとなる。JavaScriptでは引数の順番で渡る引数の内容がきまる。
### 関数名が重複して宣言されている場合
- 後から宣言された関数が有効となる。この場合、エラーも出ないので注意が必要。他の言語では引数の数が違うと異なる関数として扱う言語もあるが、JavaScriptでは関数名が同じであれば同一のものとして扱われ先に宣言された関数は後から宣言されたもので上書きされる。関数を直接宣言するのではなく、const 関数名 = 関数の内容、という宣言をすれば、constのお陰で重複した宣言があればエラーとして教えてくれる。
### 関数のデフォルト値について
- デフォルト値を設けた関数を宣言した際に実引数が渡って来なかった場合は設定しているデフォルト値が使用される。実引数がnullの場合はnullがそのまま使用され、undefinedであればデフォルト値が使用される。意図的に引数を空で扱いたい場合はnullを使用する。undefinedはコンピューターが自動で当てがう値となる。
### argumentsについて
- 関数のコンテキスト内で自動的に生成されるオブジェクト。開発者が定義することはない。中身には呼び出し時に指定された実引数がはいることになる。仮に関数で仮引数を設定していなくても実引数を渡して、arugemtnsから取得すれば仮引数無しの関数を設定することができる。arugmentsから実引数を取得することは基本的に行わないが、渡ってくる引数の数が決まっていない時に使用されることがある。但し、ES6からはレストパラメータ(...args)が導入されたので、使用頻度は減っている。レストパラメータは配列で実引数を取得できる一方でargumentsはデータの操作が配列ほど便利ではないことが起因している
### 関数は実行可能なオブジェクトである
- 先に定義した関数に対してドット記法でプロパティとして値や関数を加えることができる。また、定義した関数名の後に()をつければ、実行することができる。
### コールバック関数とは他の関数に引数として渡される関数
- 関数はオブジェクトなので、関数の引数として渡すことができる。引き渡された先で関数名の後に()を付けることで関数を実行することができる。関数を引き渡す時は名前だけで()は付けない。実行したい時に()を付けること。また、コールバック関数の場合、無名関数の場合でも引数として渡すことができる。setTimeout(関数名, 秒数)は指定の鋲巣後に関数を実行することができるが、この設定をすればコード中のある関数を切り出してしまうことができる。切り出せば必要な所に何度も再利用することができる。
### thisは呼び出し元のオブジェクトへの参照を保持するキーワード
- 実行コンテキストによってthisの参照先は変わる。person.hello(); const person = { name: 'Tom', hello: function() {console.log('Hello ' + this.name)};}の場合、this.nameの呼び出し元はperson.hello();のpersonなので、person.nameを参照する。但し、const ref = person.helloのように他の変数へ代入してしまうと、呼び出し元が無くなるのでthis.nameの部分は動作しなくなる。thisがオブジェクトのメソッドとして実行される場合は呼び出し元のオブジェクトとなり、オブジェクトを介さずに関数として呼び出しされる場合はthisはグローバルオブジェクトとなる。グローバルオブジェクトの場合、例えばwindow.name = 名前と記述すればthis.nameの部分が参照することができる。thisの値が何かわからなくなった場合はブラウザの開発用ツールでsorucesに表示される。どこかでブレイクポイントを設けること。
## 次やること
- 【JS】ガチで学びたい人のためのJavaScriptメカニズム
## 感じたこと
- 日報の書き方についてシンプルな箇条書きに加えてカテゴリを設けたら見やすくなった。継続していこう。
## 学習時間
- 6h 44min