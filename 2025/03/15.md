## 取り組んだ課題一覧
- 【JS】ガチで学びたい人のためのJavaScriptメカニズム
## わかったこと
ES moduleと即時関数
- 分割代入で即時関数内に代入する場合、   
const moduleB = (function({publicFn:fn, publicVal:val}) {} とすることで代入する値の名前を変更できる
- moduleA と moduleB があり、modile A側に変数や関数が定義されている時、mobule B側でmodule Aの内容をimport してプリミティブ型の値を定義された変数の値を使用しようとするとmodule B側ではmodule Aで定義された変数の値をコピーして使用するので、module Bで使用してもmodule Aの変数には何も影響がなく、同じ変数名で値が異なるので、整合性が取れなくなる。module内で定義されたプリミティブ型の値への変更はエラーがでることで実行できない。但し、プリミティブ型ではなく、オブジェクトのプロパティとして値を設定した場合は変更できるようになり、moduleの内外で整合性が保たれる。これはオブジェクトをコピーした場合はオブジェクトへの参照をコピーするので、あくまでプロパティに格納されている値は同じ値を指し、整合性が保たれる。結果としてmoduleの内外でデータを操作した場合は同じように値が操作される。プリミティブ型の値を操作したい場合は関数を使うこと
### モジュールコンテキストとモジュールスコープ
- モジュールコンテキストとグローバルコンテキストはほぼ同じだが、モジュールコンテキストではthisを使用できない。但し、オブジェクトのメソッドとして定義された場合はインスタンスをthisと見なして実行される。参照できないのはwindowオブジェクトなどのグローバルオブジェクトが参照できない
- スクリプトスコープはモジュール内ではモジュールスコープに取って代わられる
### モジュールの特徴
- " ＜script type="module" src="moduleB.js"＞ ＜/script＞"と記述した場合、読み込み対象のmoduleであるmoduleB.jsは非同期で読み込まれる
- documentのオブジェクトの中にhtmlのタグがオブジェクト形式になって入っているので、document.querySelector(引数)で引数で取得したいタグ(h1など)を記述することで、該当するタグをオブジェクトとして取得できる。
- scriptタグでmoduleを読み込む際にファイル名の後ろにdeferを続けるとHTMLの構文解析が全て終わった時点でmoduleの読み込みを実行します。deferを使わずに先にmoduleの読み込みを多なった場合、module読み込み時にはh1タグが存在しない為、エラー発生する。
- moduleを読み込む為のscriptタグが見つかった時点で読み込むのを同期処理と呼ぶ。deferを使うと非同期処理になる。type="module"を呼び出し時のコードに追記することでdeferを記述した場合と同じ挙動をとることができる。
- moduleとそれ以外の違いについて、module以外のものは複数回読み込んだ時、読み込みの回数だけ実行されるが、moduleは1回だけ実行される。moduleは1回だけしか読み込まれないので、最初の1回目に呼ばれたタイミングで実行される
- moduleに対応していないブラウザ(Internet Explorer)を使用した場合、html文書の中にscriptタグでnomoduleと入れておくことで、moduleに対応していないブラウザの時だけ実行される。alert('nomodule')をscriptタグ内に記述することでアラートを発動できる。
- type="module"を付けると、対象のモジュール内は自動的にstrict modeになります。
### Strictモード
- 通常のJavaScriptで許容される一部の書き方を制限する。
- 使用目的は意図しないバグの混入防止、予約語の確保、コードのセキュア化
- ファイルの先頭、または関数の先頭に use strict と記述することで反映される
- a = 0; とした場合、これはwindowオブジェクトに変数を設定する行為となり、strictモードではエラーとなる。これによりバグの原因を取り除いている。
- 予約語の確保では将来的にバージョンアップした時に使用される可能性があるキーワードは変数宣言などで使用できない。
- JavaScriptのthisに関わる所でコードをセキュア化する。関数内で return this; と記述した場合、通常モードではthis はwindowオブジェクトを指している。strictモードでthisをreturnした際にwindowオブジェクトを返す場合は無駄な脆弱性を招きかねないという判断の元にundefinedを返すように設計されている。なるべく無駄なオブジェクトを露出しないようにという考えに基づいている。
- 通常モードではthisは常にオブジェクトを参照するように設定されているが、strict modeではthisはプリミティブ型の値も取ることができる。return this; が定義された関数を関数.call(2); として実行した場合、strict modeでは 2が返ってきて、通常モードではオブジェクトでラップされた2が返ってくる
- strict mode での開発はこれらの理由によりおすすめ。
### Strictモードとクラス
- クラスのconstructorやメソッドの中では自動的にStrictモードがONになっている。
### ダイナミックインポート
- export宣言されたものを非同期で読み込むことができる。
- import(moduleのパス) でmodule内でexport宣言されている定義を全てimportできる。この宣言でimportした場合、返ってくるデータはPromiseとなるので、import(moduleのパス).then(関数)とすることで受け取ったimport内容を使用できる。
- ダイナミックインポートを使えば、必要になった時に非同期でmoduleからimportできるようになる。これにより処理が早くなるので、UXも改善される。
- async awaitを使っても同様の実装が可能
### Proxy オブジェクト
- プロパティの操作に独自の処理を追加するためのオブジェクト
- プロパティ経由で値を代入、参照、削除などした場合、任意の処理を追加することができる
- 実用的な使い方①：値が代入される際にthrow new Errorを設定しておけば、代入時にエラーを表示
- 実用的な使い方②：値が削除される際にthrow new Errorを設定しておけば、削除できなくなる
- 実用的な使い方③：所持していないプロパティを取得しようとしたら、if文でデフォルト値を返却
- handlerのreceiverにはProxyのオブジェクトが入ることになる
### Reflect
- JSエンジンの内部の汎用的な関数を呼び出すメソッドが格納されているオブジェクト
- 使用目的①：内部メソッドを呼び出す関数の格納場所
- 使用目的②：Proxyと併せて使用する為
- Classからnew演算子を使って新しいオブジェクトを生成する時に内部ではReflect.constructが実行されている。   
Reflect.construct(クラス名、配列で引数) と実行することでnew演算子を使った場合と同じ挙動となる
- 通常、演算子を用いて表記していたコードを関数表記に変更することができる
- 指定のオブジェクトにプロパティが含まれるかどうか、'プロパティ名' in オブジェクト名で記述する。これをReflectを使って記述すると Reflect.has(オブジェクト名, プロパティ名)となる
- newなどの演算子は表記が簡略化され、目的も分かりやすいが、関数表記で書きたい時がある。例えば、コールバック関数として渡したい場合、Rflectを使った関数の場合はそのまま渡せるが、new演算子の場合はそのままでは渡せないので、一度関数定義した後に引き渡せるようになる
- Object.definePropertyでは失敗するとエラーとなるが、Reflect.definePropertyでは失敗の場合はfalseが返ってくるので、if文の条件式として使用できる
- Reflect.get(tom, 'hello', receiver) とした場合、receiverに設定されたオブジェクトがgetメソッド内のthisを束縛する。この挙動により第三引数のreceiverはbindと同じようにthisを束縛する機能がある。第三引数が省略された場合は第一引数と第三引数は同じオブジェクトが使用される
## 次やること
- 【JS】ガチで学びたい人のためのJavaScriptメカニズム
## 感じたこと
- 体調悪いけど、何とか勉強時間確保、ロードマップを進められた
## 学習時間
- 5h 44min